class Solution {
    public int maximumScore(int[] A, int k) {

         int res = A[k], mini = A[k], i = k, j = k, n = A.length;

        while (i > 0 || j < n - 1) {

            //we reached left end, so i can only check right values now
            if (i == 0)
                ++j;

            //we reached right end    
            else if (j == n - 1)
                --i;


            else if (A[i - 1] < A[j + 1])
                ++j;
            else
                --i;


            mini = Math.min(mini, Math.min(A[i], A[j]));
            res = Math.max(res, mini * (j - i + 1));
        }
        return res;
        
    }
}

// 0-3
// 0-4
// 0-5...

// 1-3
// 2-3
// 3

// so 'i' should be <=k

// and 'j' should be >=k

// find all subarray with this


// i=0 ,  j=k
// while(i<=k && j<n) find all subaaray



// You take the interval (k, k) as your base case, and min=nums[k]
// You want to increase the interval.
// Note: Edge cases are when leftEnd = 0 and rightEnd = len(nums) - 1



// We start with i = j = k, the score = A[k].
// When increment the size of window,
// we want to reduce the min(A[i]..A[j]) slowly.

// To do this, we can check the values on both sides of the window.
// If A[i - 1] < A[j + 1], we do j = j + 1
// If A[i - 1] >= A[j + 1], we do i = i - 1

// During this process,
// there is sense that we reduce min(A[i]..A[j]) step by step.
