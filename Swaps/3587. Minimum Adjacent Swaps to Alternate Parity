class Solution {
public:
       int countSwaps(vector<int>& nums, int state){
        int n = nums.size();
        int minSwaps = 0, expectedPos = 0;

        for(int currPos = 0; currPos <n; currPos++){

            if(nums[currPos]%2 == state){

                // why not just minswaps++ but abs diff of pos because prblm is 
                // asking for adjacent swaps
                minSwaps += abs(currPos - expectedPos);
                expectedPos += 2;
            }
        }

        return minSwaps;
    }
   
    int minSwaps(vector<int>& nums) {

         int n = nums.size();
        int oddCnt = 0, evenCnt = 0;
        for(int i = 0; i < n; i++){
            if(nums[i]%2) oddCnt++;
            else evenCnt++;
        }


        if(abs(oddCnt - evenCnt) > 1) return -1;

// if even cnt is bigger its better to swap even numbers 
// as it would be min to place them in their curr place

        if(evenCnt > oddCnt) return countSwaps(nums, 0);

        else if(oddCnt > evenCnt) return countSwaps(nums, 1);
        else return min(countSwaps(nums, 0), countSwaps(nums, 1));

        return -1;
        
    }
};


// If we have more evens, the first character must be even.
// If we have more odds, the first character must be odd


// To alternate parity, you need to place evens and odds at alternate positions:
// [even, odd, even, odd, …] or [odd, even, odd, even, …]

// Now let’s say:

// Total length = n

// Number of evens = E

// // Number of odds = O

// For alternating parity:
// You will have ceil(n/2) numbers in even indices (0, 2, 4, …)

// And floor(n/2) numbers in odd indices (1, 3, 5, …)

// So:

// If E > O, only way to fit more evens is if the array starts with even (even positions: 0, 2, 4…)

// If O > E, must start with odd

// If E == O, you can choose either pattern — and pick the one with fewer swaps
