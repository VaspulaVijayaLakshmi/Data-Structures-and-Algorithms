class Solution {
public:
    string reorganizeString(string s) {
        unordered_map<char, int> freq_map;
        
        for (char c : s) {
            freq_map[c]++;
        }

        priority_queue<pair<int, char>> max_heap;
        for (auto &[ch, freq] : freq_map) {
            max_heap.push({freq, ch});
        }

        string res;
        while (max_heap.size() >= 2) {

            //take the 2 max, occuring element
            // aaaabbbc

            // a - 4 , b - 3 , c-1

            auto [freq1, char1] = max_heap.top(); max_heap.pop();
            auto [freq2, char2] = max_heap.top(); max_heap.pop();

            // char 1 - 'a' ,  char 2 - 'b'
            res += char1;
            res += char2;

            // res = "ab"
            // again push back a and b,

            if (--freq1 > 0) max_heap.push({freq1, char1});
            if (--freq2 > 0) max_heap.push({freq2, char2});
        }


        if (!max_heap.empty()) {
            auto [freq, ch] = max_heap.top();
            //if there is only one type of char and its 
            // more than 1 char , we can place it alternately
            if (freq > 1) return "";
            res += ch;
        }

        return res;
    }
};


// a _ a 
// a _ a _ a

// Here n=1 always , so slt grp size =1
// n=1


// aaaabbbcc

// a_a_a_a
// abababac_c -  X




// https://leetcode.com/problems/reorganize-string/

____________________________________________




// HASHMAP


class Solution {
public:
    string reorganizeString(std::string s) {
    
    unordered_map<char, int> freq_map;
    
    for (char c : s) {
        freq_map[c]++;
    }

    vector<char> sorted_chars;
    for (auto& pair : freq_map) {
        sorted_chars.push_back(pair.first);
    }

// sort
    sort(sorted_chars.begin(), sorted_chars.end(), [&](char a, char b) {
        return freq_map[a] > freq_map[b];
    });


// if an element has occurred for more than n/2, then we cant organise
//array is sorted in descending order, we need to check only 1st element
    if (freq_map[sorted_chars[0]] > (s.length() + 1) / 2) {
        return "";
    }


    std::string res(s.length(), ' ');
    int i = 0;

    for (char c : sorted_chars) {
        //for each char in sorted array

        for (int j = 0; j < freq_map[c]; ++j) {

            //we filled the even indices now we need 
            // to start from the odd indices
            if (i >= s.length()) {
                i = 1;
            }

            res[i] = c;
            i += 2;

        }
    }

    return res;
}
};
