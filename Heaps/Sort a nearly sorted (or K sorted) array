The main idea is to sort the array efficiently from left to right by considering elements from the right side. For each position i, we find the minimum element in the range [i, i + k] with help of min-heap. we don't need to check numbers from left side as they are already at their correct positions.

Step by Step implementation:

Push the first k elements of the array into the min-heap. These elements form the initial search range for sorting the first few indices.
Iterate through the remaining elements of the array (from index k to n-1). For each element:
Push it into the min-heap.
The heap now contains k + 1 elements, so remove the smallest element (top of the heap) and place it at its correct position in the array (arr[i-k]).
After processing all elements in the array, the heap still contains the last k elements. Extract these elements one by one and place them in the remaining positions of the array.



#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

//  function to sorts a nearly sorted array
// where every element is at most
// k positions away from its target position.
void nearlySorted(vector<int> &arr, int k) {

    // length of array
    int n = arr.size();

    // creating a min heap
    priority_queue<int, vector<int>, greater<int>> pq;

    // pushing first k elements in pq
    for (int i = 0; i < k; i++)
        pq.push(arr[i]);

    int i;

    for (i = k; i < n; i++) {

        pq.push(arr[i]);

        // size becomes k+1 so pop it
        // and add minimum element in (i-k) index
        arr[i - k] = pq.top();
        pq.pop();
    }

    // puting remaining elements in array
    while (!pq.empty()) {
        arr[i - k] = pq.top();
        pq.pop();
        i++;
    }
}

int main() {
    vector<int> arr = {6, 5, 3, 2, 8, 10, 9};
    int k = 3;
    nearlySorted(arr, k);
    for (int x : arr)
        cout << x << ' ';
    return 0;
}
